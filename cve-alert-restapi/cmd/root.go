package cmd

import (
	alertmanager "cve-alert-manager"
	request_handler "cve-alert-manager/cve-alert-restapi/request-handler"
	"fmt"
	"github.com/davecgh/go-spew/spew"
	_ "github.com/go-sql-driver/mysql" //needed for initializing connection
	"github.com/jmoiron/sqlx"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"log/syslog"
	"os"
	"strings"
)

var cfgFile string
var db *sqlx.DB

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "cve-alert-restapi",
	Short: "Provides a restAPI for the fetcher",
	Long: `This tool is part of the suit, this component is responsible for providing a restAPI for the fetcher tool

Normally the program is consistently running in the background to provide the API for managing and getting the infos out of the db, which is filled by the fetcher tool

All parameters (such as access data) can be specified both on the command line and in a config file `,
	// Uncomment the following line if your bare application
	// has an action associated with it:
	Run: func(cmd *cobra.Command, args []string) {
		if !viper.GetBool("syslog") {
			log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
		} else {
			log.Logger = log.Output(zerolog.SyslogLevelWriter(&syslog.Writer{}))
		}
		loglevel := cmd.Flag("log-level").Value.String()
		if !validateLogLevel(loglevel) {
			log.Error().
				Msg("Invalid log-level")
			os.Exit(1)
		}
		err := parseAndSetLogLevel(loglevel)
		if err != nil {
			log.Error().
				AnErr("Error: ", err).
				Msg("The Log Level could not be parsed")
			os.Exit(1)
		}
		if viper.GetString("cveDatabase.driverName") == "" {
			log.Error().
				Msg("config variable cveDatabase.driverName is not set")
			return
		}
		if viper.GetString("cveDatabase.dataSourceName") == "" {
			log.Error().
				Msg("config variable cveDatabase.dataSourceName is not set")
			return
		}
		db, err = sqlx.Open(viper.GetString("cveDatabase.driverName"), viper.GetString("cveDatabase.dataSourceName"))
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Could not connect to database")
			return
		}
		if viper.GetBool("read-db") {
			cve := alertmanager.CveCase{CaseId: "1"}
			cve.ReadFromDB(db)
			spew.Dump(cve)
			os.Exit(0)
		}
		port := cmd.Flag("port").Value.String()
		if port == "0" || port == "" {
			if viper.GetString("restApi.port") == "" {
				port = "1323"
			} else {
				port = viper.GetString("restApi.port")
			}
		}
		request_handler.StartWebServer(db, port)
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)
	// Here you will define your flags and configuration settings.
	// Cobra supports persistent flags, which, if defined here,
	// will be global for your application.

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/config.yaml)")
	rootCmd.Flags().String("log-level", "info", "Use this flag to set the log level")
	rootCmd.Flags().Bool("read-db", false, "Use this flag to read an entry from database for testing/debugging purposes")
	rootCmd.Flags().Int("port", 0, "Use this flag to set the restapi http port (default 1323)")
	rootCmd.Flags().Bool("syslog", false, "Use this flag to log to syslog")
	viper.BindPFlag("read-db", rootCmd.Flags().Lookup("read-db"))
	viper.BindPFlag("syslog", rootCmd.Flags().Lookup("syslog"))
	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	// rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			log.Error().
				AnErr("Error:", err)
		}
		// Search config
		viper.AddConfigPath(home + "/.cve-alert-manager")
		viper.AddConfigPath("../config")
		viper.AddConfigPath("/var/opt/cve-alert-manager")
		viper.SetConfigName("config")
	}

	replacer := strings.NewReplacer(".", "_")
	viper.SetEnvKeyReplacer(replacer)

	viper.SetEnvPrefix("CVE_ALERT_MANAGER")
	viper.AutomaticEnv() // read in environment variables that match

	err := viper.ReadInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}

	viper.SetConfigName("filter_config")
	err = viper.MergeInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}
}

func parseAndSetLogLevel(loglevel string) error {
	parsedLoglevel, err := zerolog.ParseLevel(loglevel)
	if err != nil {
		log.Error().
			AnErr("Error: ", err)
		return err
	}
	zerolog.SetGlobalLevel(parsedLoglevel)
	return nil
}

func validateLogLevel(level string) bool {
	allowedLevels := []string{"panic", "fatal", "error", "warn", "info", "debug", "trace"}

	for _, allowedLevel := range allowedLevels {
		if level == allowedLevel {
			return true
		}
	}

	return false
}
