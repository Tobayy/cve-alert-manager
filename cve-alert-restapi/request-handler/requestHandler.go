package requesthandler

import (
	"crypto/subtle"
	alertmanager "cve-alert-manager"
	"fmt"
	"github.com/huandu/go-sqlbuilder"
	"github.com/jmoiron/sqlx"
	"github.com/labstack/echo"
	"github.com/labstack/echo/middleware"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"net/http"
	"regexp"
	"strconv"
)

var db *sqlx.DB

// StartWebServer starts the rest API.
func StartWebServer(database *sqlx.DB, port string) {
	db = database
	e := echo.New()

	if !((viper.GetString("restapi.username") == "user") && (viper.GetString("restapi.password") == "pass")) &&
		!((viper.GetString("restapi.username") == "") && (viper.GetString("restapi.password") == "")) {
		e.Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) {
			// Be careful to use constant time comparison to prevent timing attacks
			if subtle.ConstantTimeCompare([]byte(username), []byte(viper.GetString("restapi.username"))) == 1 &&
				subtle.ConstantTimeCompare([]byte(password), []byte(viper.GetString("restapi.password"))) == 1 {
				return true, nil
			}
			return false, nil
		}))
	}

	//TODO ausgabe spezifizieren

	// swagger:route GET /cvecase cvecase getAllCveCases
	// ---
	// Lists all CVE cases.
	// responses:
	//   200: description: Returns all CVE cases as an array.
	//   404: description: Returns a string that there are no cases in the DB.
	e.GET("/cvecase", getAllCveCases)

	// swagger:operation GET /cvecase/{id} cvecase getCveCase
	// ---
	// summary: Gets a specific CVE case.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the case.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the specific CVE case.
	//     schema:
	//       $ref: '#/definitions/CveCase'
	//   404:
	//     description: Returns a string that the specified CVE case is not in the DB.
	e.GET("/cvecase/:id", getCveCase)

	// swagger:operation GET /cvecase/{id}/comments cvecase getCveCaseComments
	// ---
	// summary: Gets all comments of a specific CVE case.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the case.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the comments.
	//     schema:
	//       type: array
	//       items:
	//         $ref: '#/definitions/CveCaseComment'
	//   404:
	//     description: Returns a string that the specified CVE case is not in the DB or if it doesn`t have any comments.
	e.GET("/cvecase/:id/comments", getCveCaseComments)

	// swagger:operation POST /cvecase/search cvecase searchCveCases
	// ---
	// summary: Searches after CVE cases.
	// consumes:
	// - application/json
	// produces:
	// - application/json
	// parameters:
	// - name: body
	//   in: body
	//   description: Criteria for the search.
	//   required: true
	//   schema:
	//     $ref: '#/definitions/CveCaseSearchCriteria'
	// responses:
	//   200:
	//     description: Returns the result of the search.
	//     schema:
	//       $ref: '#/definitions/CveCaseSearchResult'
	//   400:
	//     description: Returns a string that the date was formatted wrong.
	//   404:
	//     description: Returns a string that there are no matches for the criteria in the DB.
	e.POST("/cvecase/search", searchCveCases)

	//TODO ausgabe spezifizieren

	// swagger:route GET /filter filter getAllFilters
	// ---
	// Lists all filters.
	// produces:
	// - application/json
	// responses:
	//   200: description: Returns all filters as an array.
	//   404: description: Returns a string that there are no filters in the DB.
	e.GET("/filter", getAllFilters)

	// swagger:operation POST /filter/add filter addFilter
	// ---
	// summary: Adds a filter.
	// consumes:
	// - application/json
	// parameters:
	// - name: body
	//   in: body
	//   description: Filter which should be added, id will be set automatically.
	//   required: true
	//   schema:
	//     $ref: '#/definitions/Filter'
	// responses:
	//   200:
	//     description: Returns a string that adding filter was successful.
	e.POST("/filter/add", addFilter)

	// swagger:operation GET /filter/{id} filter getFilter
	// ---
	// summary: Gets a specific filter.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the filter.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the specific filter.
	//     schema:
	//       $ref: '#/definitions/Filter'
	//   404:
	//     description: Returns a string that the specified filter is not in the DB.
	e.GET("/filter/:id", getFilter)

	// swagger:operation PUT /filter/{id} filter changeFilter
	// ---
	// summary: Changes a specific filter name.
	// consumes:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of filter to change.
	//   required: true
	//   type: integer
	// - name: body
	//   in: body
	//   description: The filter which should be changed, thus only key "filter" should be set, all other values will be ignored.
	//   required: true
	//   schema:
	//     $ref: '#/definitions/Filter'
	// responses:
	//   200:
	//     description: Returns a string that the change was successful.
	//   404:
	//     description: Returns a string that the specified filter ID is not in the DB.
	e.PUT("/filter/:id", changeFilter)

	// swagger:operation DELETE /filter/{id} filter deleteFilter
	// ---
	// summary: Deletes a specific filter.
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the filter.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns a string that remove was successful.
	//   404:
	//     description: Returns a string that the specific filter is not in db.
	e.DELETE("/filter/:id", deleteFilter)

	// swagger:operation GET /filter/{id}/cases filter getFilterCases
	// ---
	// summary: Gets all cases of a specific filter.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the filter.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the specific cases.
	//     schema:
	//       type: array
	//       items:
	//         $ref: '#/definitions/CveCase'
	//   404:
	//     description: Returns a string that the specified filter is not in the DB.
	e.GET("/filter/:id/cases", getFilterCases)

	// swagger:operation GET /filter/{id}/categories filter getFilterCategoriesOfFilter
	// ---
	// summary: Gets all filter categories of a specific filter.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the filter.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the filter categories.
	//     schema:
	//       type: array
	//       items:
	//         $ref: '#/definitions/FilterCategory'
	//   404:
	//     description: Returns a string that there are no filter categories for the specified filter.
	e.GET("/filter/:id/categories", getFilterCategoriesOfFilter)

	// swagger:operation Post /filter/import filter importFilter
	// ---
	// summary: Imports filter from a file.
	// consumes:
	// - multipart/form-data
	// parameters:
	// - in: formData
	//   name: filterConfig
	//   type: file
	//   description: Filter config file to upload, should be a YAML File. Look at the default filter_config.yaml for a example how the file should be formatted.
	// responses:
	//   200:
	//     description: Returns a string that importing was successful.
	e.POST("/filter/import", importFilter)

	//TODO ausgabe spezifizieren

	// swagger:route GET /filter/export filter exportFilter
	// ---
	// Exports all filters and filter categories.
	// responses:
	//   200: description: Returns all filters and filter categories as an array.
	e.GET("/filter/export", exportFilter)

	// swagger:operation POST /comment/add comment addComment
	// ---
	// summary: Adds a comment.
	// consumes:
	// - application/json
	// parameters:
	// - name: body
	//   in: body
	//   description: Comment which should be added, "id", "date_created" and "date_updated" will be set automatically.
	//   required: true
	//   schema:
	//     $ref: '#/definitions/CveCaseComment'
	// responses:
	//   200:
	//     description: Returns a string that adding comment was successful.
	//   404:
	//     description: Returns a string that the desired case ID doesn't exist.
	e.POST("/comment/add", addComment)

	// swagger:operation GET /comment/{id} comment getComment
	// ---
	// summary: Gets a specific comment.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the comment.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the specific comment.
	//     schema:
	//       $ref: '#/definitions/CveCaseComment'
	//   404:
	//     description: Returns a string that the specified comment is not in the DB.
	e.GET("/comment/:id", getComment)

	// swagger:operation PUT /comment/{id} comment changeComment
	// ---
	// summary: Changes a specific comment.
	// consumes:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the comment to change.
	//   required: true
	//   type: integer
	// - name: body
	//   in: body
	//   description: The comment which should be changed, thus only key "comment" and "username" should be set, all other values will be ignored.
	//   required: true
	//   schema:
	//     $ref: '#/definitions/CveCaseComment'
	// responses:
	//   200:
	//     description: Returns a string that the change was successful.
	//   404:
	//     description: Returns a string that the specified comment is not in the DB.
	e.PUT("/comment/:id", changeComment)

	// swagger:operation DELETE /comment/{id} comment deleteComment
	// ---
	// summary: Delete a specific comment.
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the comment.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns a string that removing was successful.
	//   404:
	//     description: Returns a string that the specified comment is not in the DB.
	e.DELETE("/comment/:id", deleteComment)

	//TODO ausgabe spezifizieren

	// swagger:route GET /filtercategory filtercategory getAllFilterCategories
	// ---
	// Lists all filter categories.
	// produces:
	// - application/json
	// responses:
	//   200: description: Returns all filter categories as an array.
	//   404: description: Returns a string that there are no filter categories in the DB.
	e.GET("/filtercategory", getAllFilterCategories)

	// swagger:operation POST /filtercategory/add filtercategory addFilterCategory
	// ---
	// summary: Adds a filter category.
	// consumes:
	// - application/json
	// parameters:
	// - name: body
	//   in: body
	//   description: Filter category which should be added, id will be set automatically.
	//   required: true
	//   schema:
	//     $ref: '#/definitions/FilterCategory'
	// responses:
	//   200:
	//     description: Returns a string that adding comment was successful.
	//   404:
	//     description: Returns a string that the specified filter category is already in the DB.
	e.POST("/filtercategory/add", addFilterCategory)

	// swagger:operation GET /filtercategory/{id} filtercategory getFilterCategory
	// ---
	// summary: Gets a specific filter category.
	// produces:
	// - application/json
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the filter category.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns the specific filter category.
	//     schema:
	//       $ref: '#/definitions/FilterCategory'
	//   404:
	//     description: Returns a string that the specified filter category is not in the DB.
	e.GET("/filtercategory/:id", getFilterCategory)

	// swagger:operation DELETE /filtercategory/{id} filtercategory deleteFilterCategory
	// ---
	// summary: Delete a specific filter category.
	// parameters:
	// - name: id
	//   in: path
	//   description: ID of the filter category.
	//   type: integer
	//   required: true
	// responses:
	//   200:
	//     description: Returns a string that remove was successful
	//   404:
	//     description: Returns a string that the specific comment is not in db
	e.DELETE("/filtercategory/:id", deleteFilterCategory)

	//TODO ausgabe spezifizieren

	// swagger:route GET /category category getAllCategories
	// ---
	// Lists all categories.
	// produces:
	// - application/json
	// responses:
	//   200: description: Returns all categories as an array.
	//   404: description: Returns a string that there are no categories in the DB.
	e.GET("/category", getAllCategories)

	// swagger:route GET /category/other category getCategoriesOfOther
	// ---
	// Lists all categories which aren't in a filter.
	// produces:
	// - application/json
	// responses:
	//   200: description: Returns all categories as an array.
	//   404: description: Returns a string that there are no categories which aren't in a filter.
	e.GET("/category/other", getCategoriesOfOther)

	// swagger:route GET /platform platform getPlatforms
	// ---
	// Lists all platforms.
	// produces:
	// - application/json
	// responses:
	//   200: description: Returns all platforms as an array.
	//   404: description: Returns a string that there are no platforms.
	e.GET("/platform", getPlatforms)

	e.Logger.Fatal(e.Start(":" + port))
}

func getAllCveCases(c echo.Context) error {
	result, err := alertmanager.SearchCases(db, *new(alertmanager.CveCaseSearchCriteria))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	if result == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, result)
}

func getCveCase(c echo.Context) error {
	criteria := alertmanager.CveCaseSearchCriteria{CaseId: c.Param("id")}
	result, err := alertmanager.SearchCases(db, criteria)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	if result == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, result[0])
}

func getCveCaseComments(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not parse id")
		return err
	}
	cvecase := alertmanager.CveCase{CaseId: strconv.Itoa(id)}
	result, err := alertmanager.SearchCommentsOfCveCase(db, cvecase)
	if err != nil || result == nil {
		return c.String(http.StatusNotFound, "Comment not found!\n")
	}
	return c.JSON(http.StatusOK, result)
}

func searchCveCases(c echo.Context) error {
	criteria := alertmanager.CveCaseSearchCriteria{}
	if err := c.Bind(&criteria); err != nil {
		return err
	}
	if criteria.FirstDate != "" {
		regex := regexp.MustCompile("^....-..-..\\z")
		if !regex.MatchString(criteria.FirstDate) {
			return c.String(http.StatusBadRequest, "FirstDate formatted wrong!\n")
		}
	}
	if criteria.LastDate != "" {
		regex := regexp.MustCompile("^....-..-..\\z")
		if !regex.MatchString(criteria.LastDate) {
			return c.String(http.StatusBadRequest, "LastDate formatted wrong!\n")
		}
	}
	result, err := alertmanager.SearchCases(db, criteria)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	criteria.Amount = ""
	criteria.Offset = "0"
	resultAll, err := alertmanager.SearchCases(db, criteria)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	currentlyShown := strconv.Itoa(len(result))
	totalResults := strconv.Itoa(len(resultAll))

	searchResult := alertmanager.CveCaseSearchResult{Total: totalResults, CurrentlyShown: currentlyShown, Data: result}

	if result == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, searchResult)
}

func getAllFilters(c echo.Context) error {
	var filtersDBList []alertmanager.Filter
	err := db.Select(&filtersDBList, db.Rebind("SELECT * FROM filters"))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	if filtersDBList == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, filtersDBList)
}

func addFilter(c echo.Context) error {
	filter := alertmanager.Filter{}
	if err := c.Bind(&filter); err != nil {
		return err
	}
	err := alertmanager.AddFilter(db, filter.Filter)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not add filter")
		return err
	}
	return c.String(http.StatusOK, "Filter added!\n")
}

func getFilter(c echo.Context) error {
	var filterList []alertmanager.Filter
	sb := sqlbuilder.MySQL.NewSelectBuilder()
	sb.Select("*").From("filters").Where(sb.Equal("id", c.Param("id")))
	sql, args := sb.Build()
	query, err := sqlbuilder.MySQL.Interpolate(sql, args)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not build sql query")
		return err
	}
	err = db.Select(&filterList, query)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	if filterList == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, filterList[0])
}

func changeFilter(c echo.Context) error {
	filter := alertmanager.Filter{}
	if err := c.Bind(&filter); err != nil {
		return err
	}
	if filter.Filter == "" {
		return c.String(http.StatusBadRequest, "New filtername is empty!\n")
	}
	err := alertmanager.ChangeFilter(db, filter, c.Param("id"))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not change filter")
		return c.String(http.StatusNotFound, "Filter is not in DB!\n")
	}
	return c.String(http.StatusOK, "Successfully updated filter!\n")
}

func deleteFilter(c echo.Context) error {
	err := alertmanager.DeleteFilter(db, c.Param("id"))
	if err != nil {
		return c.String(http.StatusNotFound, "Filter not in DB!\n")
	}
	return c.String(http.StatusOK, "Filter removed!\n")
}

func getFilterCases(c echo.Context) error {
	var filterList []alertmanager.Filter
	sb := sqlbuilder.MySQL.NewSelectBuilder()
	sb.Select("*").From("filters").Where(sb.Equal("id", c.Param("id")))
	sql, args := sb.Build()
	query, err := sqlbuilder.MySQL.Interpolate(sql, args)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not build sql query")
		return err
	}
	err = db.Select(&filterList, query)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}
	if filterList == nil {
		return c.String(http.StatusNotFound, "Filter not in DB!\n")
	}
	criteria := alertmanager.CveCaseSearchCriteria{Filter: filterList[0].Filter}
	var cases []alertmanager.CveCase
	cases, err = alertmanager.SearchCases(db, criteria)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}
	return c.JSON(http.StatusOK, cases)
}

func getFilterCategoriesOfFilter(c echo.Context) error {
	var filterCategories []alertmanager.FilterCategory
	sb := sqlbuilder.MySQL.NewSelectBuilder()
	sb.Select("*").From("filter_categories").Where(sb.Equal("filter_id", c.Param("id")))
	sql, args := sb.Build()
	query, err := sqlbuilder.MySQL.Interpolate(sql, args)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not build sql query")
		return err
	}
	err = db.Select(&filterCategories, query)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}
	if filterCategories == nil {
		return c.String(http.StatusNotFound, "No filter categories found!\n")
	}
	return c.JSON(http.StatusOK, filterCategories)
}

func importFilter(c echo.Context) error {
	requestFile, err := c.FormFile("filterConfig")
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not load attached file")
		return err
	}

	file, err := requestFile.Open()
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not open file")
		return err
	}
	defer file.Close()

	buffer := make([]byte, requestFile.Size)
	_, err = file.Read(buffer)
	if err != nil {
		fmt.Println(err)
		return err
	}

	err = alertmanager.ImportFilterFromBuffer(db, buffer)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not import filter")
		return err
	}

	return c.String(http.StatusOK, "Successfully imported filters!\n")
}

func exportFilter(c echo.Context) error {
	filter, err := alertmanager.ExportFilterConfig(db)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not export filter")
		return err
	}
	return c.String(http.StatusOK, filter)
}

func addComment(c echo.Context) error {
	comment := alertmanager.CveCaseComment{}
	if err := c.Bind(&comment); err != nil {
		return err
	}
	err := alertmanager.AddComment(db, comment)
	if err != nil {
		return c.String(http.StatusBadRequest, "Comment data is defective\n")
	}
	return c.String(http.StatusOK, "Added comment successfully!\n")
}

func getComment(c echo.Context) error {
	comment := alertmanager.CveCaseComment{CommentId: c.Param("id")}
	result, err := alertmanager.SearchComment(db, comment)
	if err != nil {
		return err
	}
	if result == nil {
		return c.String(http.StatusNotFound, "Comment not found!\n")
	}
	return c.JSON(http.StatusOK, result[0])
}

func changeComment(c echo.Context) error {
	comment := alertmanager.CveCaseComment{CommentId: c.Param("id")}
	if err := c.Bind(&comment); err != nil {
		return err
	}
	err := alertmanager.ChangeComment(db, comment)
	if err != nil {
		return c.String(http.StatusNotFound, "Comment data is defective\n")
	}
	return c.String(http.StatusOK, "Updated successfully\n")
}

func deleteComment(c echo.Context) error {
	err := alertmanager.RemoveComment(db, c.Param("id"))
	if err != nil {
		return c.String(http.StatusNotFound, "Could not remove comment!\n")
	}
	return c.String(http.StatusOK, "Comment removed successfully!\n")
}

func getAllFilterCategories(c echo.Context) error {
	filterCategories, err := alertmanager.ExportFilterCategories(db)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not export filters")
		return err
	}
	return c.JSON(http.StatusOK, filterCategories)
}

func addFilterCategory(c echo.Context) error {
	filterCategory := new(alertmanager.FilterCategory)
	if err := c.Bind(filterCategory); err != nil {
		return err
	}
	err := alertmanager.AddFilterCategory(db, filterCategory.FilterId, filterCategory.Category)
	if err != nil {
		return c.String(http.StatusNotFound, "Filter Category already in DB!\n")
	}
	return c.String(http.StatusOK, "Added filter category!\n")
}

func getFilterCategory(c echo.Context) error {
	var filterCategoryList []alertmanager.FilterCategory
	sb := sqlbuilder.MySQL.NewSelectBuilder()
	sb.Select("*").From("filter_categories").Where(sb.Equal("id", c.Param("id")))
	sql, args := sb.Build()
	query, err := sqlbuilder.MySQL.Interpolate(sql, args)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not build sql query")
		return err
	}
	err = db.Select(&filterCategoryList, query)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	if filterCategoryList == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, filterCategoryList)
}

func deleteFilterCategory(c echo.Context) error {
	Id := c.Param("id")
	err := alertmanager.DeleteFilterCategory(db, Id)
	if err != nil {
		return c.String(http.StatusNotFound, "Could not find filter category\n")
	}
	return c.String(http.StatusOK, "Successfully deleted\n")
}

func getAllCategories(c echo.Context) error {
	var categoryList []alertmanager.Category
	sb := sqlbuilder.MySQL.NewSelectBuilder()
	sb.Select("category").From("case_categories").GroupBy("category")
	sql, args := sb.Build()
	query, err := sqlbuilder.MySQL.Interpolate(sql, args)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not build sql query")
		return err
	}
	err = db.Select(&categoryList, query)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}

	if categoryList == nil {
		return c.String(http.StatusNotFound, "No results found!\n")
	}
	return c.JSON(http.StatusOK, categoryList)
}

func getCategoriesOfOther(c echo.Context) error {
	var categories []alertmanager.Category
	sb := sqlbuilder.MySQL.NewSelectBuilder()
	sb.Select("category").From("case_categories").Where("case_categories.category NOT IN (SELECT category FROM filter_categories)").GroupBy("category")
	sql, args := sb.Build()
	query, err := sqlbuilder.MySQL.Interpolate(sql, args)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not build sql query")
		return err
	}
	err = db.Select(&categories, query)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}
	if categories == nil {
		return c.String(http.StatusNotFound, "No categories found!\n")
	}
	return c.JSON(http.StatusOK, categories)
}

func getPlatforms(c echo.Context) error {
	var platforms []string
	err := db.Select(&platforms, "SELECT DISTINCT platform FROM case_platforms")
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not search db")
		return err
	}
	if platforms == nil {
		return c.String(http.StatusNotFound, "Could not find platforms\n")
	}
	return c.JSON(http.StatusOK, platforms)
}
