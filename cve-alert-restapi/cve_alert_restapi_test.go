package main

import (
	alertmanager "cve-alert-manager"
	"cve-alert-manager/cve-alert-fetcher/fetcher"
	requestHandler "cve-alert-manager/cve-alert-restapi/request-handler"
	"github.com/go-resty/resty/v2"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
	"os"
	"strings"
	"testing"
	"time"
)

var cfgFile string
var db *sqlx.DB
var port string

func init() {
	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			log.Error().
				AnErr("Error:", err)
		}
		// Search config
		viper.AddConfigPath(home + "/.cve-alert-manager")
		viper.AddConfigPath("../config")
		viper.AddConfigPath("/var/opt/cve-alert-manager")
		viper.SetConfigName("config")
	}

	replacer := strings.NewReplacer(".", "_")
	viper.SetEnvKeyReplacer(replacer)

	viper.SetEnvPrefix("CVE_ALERT_MANAGER")
	viper.AutomaticEnv() // read in environment variables that match

	err := viper.ReadInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}

	viper.SetConfigName("filter_config")
	err = viper.MergeInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}

	viper.Set("init-db", true)
	viper.Set("no-dele", true)
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
	zerolog.SetGlobalLevel(zerolog.InfoLevel)

	if !viper.GetBool("dry-run") {
		var err error
		if viper.GetString("cveDatabase.driverName") == "" {
			log.Error().
				Msg("config variable cveDatabase.driverName is not set")
			return
		}
		if viper.GetString("cveDatabase.dataSourceName") == "" {
			log.Error().
				Msg("config variable cveDatabase.dataSourceName is not set")
			return
		}
		db, err = sqlx.Open(viper.GetString("cveDatabase.driverName"), viper.GetString("cveDatabase.dataSourceName"))
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Could not connect to database")
			return
		}
		if viper.GetBool("init-db") {
			log.Info().
				Msg("init-db - initialize database structure")

			err = alertmanager.InitDB(db)
			if err != nil {
				log.Error().
					AnErr("Error", err).
					Msg("Could not initialize database structure")
				return
			}
		}
	} else {
		log.Info().
			Msg("dry-run - no database changes")
	}

	fetcher.FetchCertBund(db)

	db, err = sqlx.Open(viper.GetString("cveDatabase.driverName"), viper.GetString("cveDatabase.dataSourceName"))
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to database")
	}

	if port == "0" || port == "" {
		if viper.GetString("restApi.port") == "" {
			log.Error().
				Msg("env variable is not set")
		}
		port = viper.GetString("restApi.port")
	}
	go requestHandler.StartWebServer(db, port)
	time.Sleep(time.Second)
}

func TestCveCaseRequest(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/cvecase/1"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Regexp(t, ".CB-K20/0056 Update 3 - Google Chrome: Mehrere Schwachstellen.", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestCveCaseRequestNotFound(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/cvecase/400"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 404, resp.StatusCode())
}

func TestCveCaseRequestSearch(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/cvecase/search"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter\":\"Other\",\"caseid\":\"111\"}").Post(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Regexp(t, ".CB-K19/1069 Update 6 - Xen: Mehrere Schwachstellen.", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestCveCaseRequestSearchNoResults(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/cvecase/search"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter\":\"Other\",\"caseid\":\"11\"}").Post(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "No results found!", resp.String())
	assert.Equal(t, 404, resp.StatusCode())
}

func TestFilterRequestAll(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "[{\"id\":\"1\",\"filter\":\"Linux\"},{\"id\":\"3\",\"filter\":\"Network\"},{\"id\":\"4\",\"filter\":\"Other\"},{\"id\":\"2\",\"filter\":\"Windows\"}]", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterAdd(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/add"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter\":\"IT-Betrieb\"}").Post(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Filter added!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestExportFilter(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/export"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterRequest(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/2"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "{\"id\":\"2\",\"filter\":\"Windows\"}", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterChange1(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/2"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter\":\"Systeme\"}").Put(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Successfully updated filter!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterChange2(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/2"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter\":\"Windows\"}").Put(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Successfully updated filter!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterChangeNotFound(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/7"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter\":\"Systeme\"}").Put(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 404, resp.StatusCode())
}

func TestFilterRemove(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/5"
	resp, err := client.R().Delete(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Filter removed!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterRemoveNoResults(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/23"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "No results found!", resp.String())
	assert.Equal(t, 404, resp.StatusCode())
}

func TestFilterCases(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/2/cases"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterCasesNoResults(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filter/7/cases"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 404, resp.StatusCode())
}

func TestCommentAdd(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/comment/add"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"case_id\":\"4\",\"new_status\":\"ASSIGNED\",\"username\":\"test\",\"comment\":\"TestCommandAdd\"}").Post(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Added comment successfully!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestCommentRequest(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/comment/1"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Regexp(t, ".TestCommandAdd.", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestCveCaseCommentRequest(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/cvecase/4/comments"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Regexp(t, ".TestCommandAdd.", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestCommentRequestNoResult(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/comment/7"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 404, resp.StatusCode())
}

func TestCommentChange(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/comment/1"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"comment\":\"Working on issue for 2 weeks\"}").Put(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Updated successfully", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestCommentDelete(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/comment/1"
	resp, err := client.R().Delete(url)
	if err != nil {
		log.Error().
			AnErr("Error: ", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Comment removed successfully!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterCategoriesRequestAll(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filtercategory"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterCategoriesAdd(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filtercategory/add"
	resp, err := client.R().SetHeader("Content-Type", "application/json").SetBody("{\"filter_id\":\"3\",\"category\":\"Test\"}").Post(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Added filter category!", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterCategoriesRequest(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filtercategory/13"
	resp, err := client.R().Get(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Regexp(t, ".Anwendung/Clients/Browser/Internet_Explorer.", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}

func TestFilterCategoriesDelete(t *testing.T) {
	client := resty.New()
	url := "http://localhost:" + port + "/filtercategory/82"
	resp, err := client.R().Delete(url)
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Could not connect to API")
	}
	assert.Equal(t, "Successfully deleted", resp.String())
	assert.Equal(t, 200, resp.StatusCode())
}
