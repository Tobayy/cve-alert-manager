package main

import (
	alertmanager "cve-alert-manager"
	"cve-alert-manager/cve-alert-fetcher/fetcher"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
	"os"
	"strconv"
	"strings"
	"testing"
	"time"
)

var cfgFile string
var db *sqlx.DB

func init() {
	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			log.Error().
				AnErr("Error:", err)
		}
		// Search config
		viper.AddConfigPath(home + "/.cve-alert-manager")
		viper.AddConfigPath("../config")
		viper.AddConfigPath("/var/opt/cve-alert-manager")
		viper.SetConfigName("config")
	}

	replacer := strings.NewReplacer(".", "_")
	viper.SetEnvKeyReplacer(replacer)

	viper.SetEnvPrefix("CVE_ALERT_MANAGER")
	viper.AutomaticEnv() // read in environment variables that match

	err := viper.ReadInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}

	viper.SetConfigName("filter_config")
	err = viper.MergeInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}

	viper.Set("init-db", true)
	viper.Set("no-dele", true)
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
	zerolog.SetGlobalLevel(zerolog.InfoLevel)

	if !viper.GetBool("dry-run") {
		var err error
		if viper.GetString("cveDatabase.driverName") == "" {
			log.Error().
				Msg("config variable cveDatabase.driverName is not set")
			return
		}
		if viper.GetString("cveDatabase.dataSourceName") == "" {
			log.Error().
				Msg("config variable cveDatabase.dataSourceName is not set")
			return
		}
		db, err = sqlx.Connect(viper.GetString("cveDatabase.driverName"), viper.GetString("cveDatabase.dataSourceName"))
		if err != nil {
			log.Error().
				AnErr("Error", err).
				Msg("Could not connect to database")
			return
		}
		if viper.GetBool("init-db") {
			log.Info().
				Msg("init-db - initialize database structure")

			err = alertmanager.InitDB(db)
			if err != nil {
				log.Error().
					AnErr("Error", err).
					Msg("Could not initialize database structure")
				return
			}
		}
	} else {
		log.Info().
			Msg("dry-run - no database changes")
	}

	err = alertmanager.ImportFilterFromConfig(db)
	if err != nil {
		log.Error().
			AnErr("Error", err)
	}

	fetcher.FetchCertBund(db)
}

func extractCaseIdsFromCases(CveCases []alertmanager.CveCase) ([]int64, error) {
	CaseIds := make([]int64, len(CveCases))
	for i := 0; i < len(CveCases); i++ {
		id, err := strconv.Atoi(CveCases[i].CaseId)
		if err != nil {
			log.Error().
				AnErr("Error", err)
			return nil, err
		}
		CaseIds[i] = int64(id)
	}
	return CaseIds, nil
}

//Tests

func TestSearchCasesTotalNumber(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveCaseList, err := alertmanager.SearchCases(db, cveSearch)
	assert.Equal(t, 300, len(cveCaseList), "Total Number of cases does not match", err)
}

func TestReadCaseId1(t *testing.T) {
	cve := alertmanager.CveCase{CaseId: "1"}
	err := cve.ReadFromDB(db, "1")
	assert.NoError(t, err)
	actualTime := time.Now()
	actualTimeFormatted := fmt.Sprintf("%d-%02d-%02d", actualTime.Year(), actualTime.Month(), actualTime.Day())
	DateReceivedRegExpString := `^` + actualTimeFormatted + ` \d\d:\d\d:\d\d$`
	assert.Equal(t, "CERT", cve.Source, "cve.Source does not match")
	assert.Equal(t, "CB-K20/0056 Update 3", cve.RefNum, "cve.RefNum does not match")
	assert.Equal(t, "NEW", cve.Status, "cve.Status does not match")
	assert.Equal(t, "2020-01-29 13:04:15", cve.DateCreated, "cve.DateCreated does not match")
	assert.Regexp(t, DateReceivedRegExpString, cve.DateReceived, "cve.DateReceived does not match")
	assert.Equal(t, "2", cve.Risk, "cve.Risk does not match")
	assert.Equal(t, "[CERT-Bund] CB-K20/0056 Update 3 - Google Chrome: Mehrere Schwachstellen", cve.Subject, "cve.Subject does not match")
	assert.Equal(t, "1", cve.Verified, "cve.Verified does not match")
	assert.Equal(t, "wid@mail.cert-bund.de", cve.MsgFrom, "cve.MsgFrom does not match")
	assert.Equal(t, "wid@mail.cert-bund.de", cve.MsgTo, "cve.MsgTo does not match")

	if !assert.ObjectsAreEqual([]string{"CVE-2020-0601", "CVE-2020-6378", "CVE-2020-6379", "CVE-2020-6380"}, cve.CveNumList) {
		t.Error("cve.CveNumList does not match")
	}

	if !assert.ObjectsAreEqual([]string{"Anwendung/Clients/Browser/Chrome", "Anwendung/Clients/Browser", "Anwendung/Clients/Browser/Chrome", "Anwendung/Clients/Browser/Chrome", "Betriebssystem/Linux_Unix/RedHat"}, cve.CategoryList) {
		t.Error("cve.CategoryList does not match")
	}

	if !assert.ObjectsAreEqual([]string{"Linux", "MacOS X", "UNIX", "Windows"}, cve.PlatformList) {
		t.Error("cve.PlatformList does not match")
	}

	if !assert.ObjectsAreEqual([]string{"Google Chrome 79.0.3945.130", "Google Chrome for Linux 79.0.3945.130", "Google Chrome for Mac 79.0.3945.130", "Open Source Arch Linux", "Red Hat Enterprise Linux", "Microsoft Edge (Chromium-based)"}, cve.SoftwareList) {
		t.Error("cve.SoftwareList does not match")
	}
}

func TestReadCaseId13(t *testing.T) {
	cve := alertmanager.CveCase{CaseId: "13"}
	err := cve.ReadFromDB(db, "1")
	assert.NoError(t, err)
	actualTimeId13 := time.Now()
	actualTimeFormattedId13 := fmt.Sprintf("%d-%02d-%02d", actualTimeId13.Year(), actualTimeId13.Month(), actualTimeId13.Day())
	DateReceivedRegExpStringId13 := `^` + actualTimeFormattedId13 + ` \d\d:\d\d:\d\d$`
	assert.Equal(t, "CERT", cve.Source, "cve.Source does not match at id 13")
	assert.Equal(t, "CB-K19/1000 Update 2", cve.RefNum, "cve.RefNum does not match at id 13")
	assert.Equal(t, "NEW", cve.Status, "cve.Status does not match at id 13")
	assert.Equal(t, "2020-01-29 13:22:12", cve.DateCreated, "cve.DateCreated does not match at id 13")
	assert.Regexp(t, DateReceivedRegExpStringId13, cve.DateReceived, "cve.DateReceived does not match at id 13")
	assert.Equal(t, "4", cve.Risk, "cve.Risk does not match at id 13")
	assert.Equal(t, "[CERT-Bund] CB-K19/1000 Update 2 - Linux Kernel: Mehrere Schwachstellen", cve.Subject, "cve.Subject does not match at  id 13")
	assert.Equal(t, "wid@mail.cert-bund.de", cve.MsgFrom, "msg.From does not match at id 13")
	assert.Equal(t, "wid@mail.cert-bund.de", cve.MsgTo, "cve.MsgTo does not match at id 13")

	if !assert.ObjectsAreEqual([]string{"CVE-2019-18885", "CVE-2019-19036", "CVE-2019-19037", "CVE-2019-19039"}, cve.CveNumList) {
		t.Error("cve.CveNumList does not match at id 13")
	}

	if !assert.ObjectsAreEqual([]string{"Betriebssystem/Linux_Unix", "Betriebssystem/Linux_Unix/Ubuntu"}, cve.CategoryList) {
		t.Error("cve.CategoryList does not match at id 13")
	}

	if !assert.ObjectsAreEqual([]string{"Linux"}, cve.PlatformList) {
		t.Error("cve.PlatformList does not match at id 13")
	}

	if !assert.ObjectsAreEqual([]string{"Open Source Linux Kernel < 5.3.12", "Ubuntu Linux"}, cve.SoftwareList) {
		t.Error("cve.SoftwareList does not match at id 13")
	}
}

func TestReadCaseId17(t *testing.T) {
	cve := alertmanager.CveCase{CaseId: "17"}
	err := cve.ReadFromDB(db, "1")
	assert.NoError(t, err)
	actualTimeId17 := time.Now()
	actualTimeFormattedId17 := fmt.Sprintf("%d-%02d-%02d", actualTimeId17.Year(), actualTimeId17.Month(), actualTimeId17.Day())
	DateReceivedRegExpStringId17 := `^` + actualTimeFormattedId17 + ` \d\d:\d\d:\d\d$`
	assert.Equal(t, "CERT", cve.Source, "cve.Source does not match at id 17")
	assert.Equal(t, "CB-K19/1058 Update 7", cve.RefNum, "cve.RefNum does not match at id 17")
	assert.Equal(t, "NEW", cve.Status, "cve.Status does not match at id 13")
	assert.Equal(t, "2020-01-29 13:25:46", cve.DateCreated, "cve.DateCreated does not match at id 17")
	assert.Regexp(t, DateReceivedRegExpStringId17, cve.DateReceived, "cve.DateReceived does not match at id 17")
	assert.Equal(t, "3", cve.Risk, "cve.Risk does not match at id 17")
	assert.Equal(t, "[CERT-Bund] CB-K19/1058 Update 7 - Google Chrome: Mehrere Schwachstellen", cve.Subject, "cve.Subject does not match at  id 17")
	assert.Equal(t, "wid@mail.cert-bund.de", cve.MsgFrom, "msg.From does not match at id 17")
	assert.Equal(t, "wid@mail.cert-bund.de", cve.MsgTo, "cve.MsgTo does not match at id 17")

	if !assert.ObjectsAreEqual([]string{"CVE-2019-13725", "CVE-2019-13726", "CVE-2019-13727", "CVE-2019-13728", "CVE-2019-13729", "CVE-2019-13730", "CVE-2019-13732", "CVE-2019-13734", "CVE-2019-13735", "CVE-2019-13736", "CVE-2019-13737", "CVE-2019-13738", "CVE-2019-13739", "CVE-2019-13740", "CVE-2019-13741",
		"CVE-2019-13742", "CVE-2019-13743", "CVE-2019-13744", "CVE-2019-13745", "CVE-2019-13746", "CVE-2019-13747", "CVE-2019-13748", "CVE-2019-13749", "CVE-2019-13750", "CVE-2019-13751", "CVE-2019-13752", "CVE-2019-13753", "CVE-2019-13754", "CVE-2019-13755", "CVE-2019-13756", "CVE-2019-13757", "CVE-2019-13758",
		"CVE-2019-13759", "CVE-2019-13761", "CVE-2019-13762", "CVE-2019-13763", "CVE-2019-13764"}, cve.CveNumList) {
		t.Error("cve.CveNumList does not match at id 17")
	}

	if !assert.ObjectsAreEqual([]string{"Betriebssystem/Linux_Unix/Debian", "Anwendung/Clients/Browser/Chrome", "Betriebssystem/Linux_Unix", "Betriebssystem/Linux_Unix/RedHat"}, cve.CategoryList) {
		t.Error("cve.CategoryList does not match at id 17")
	}

	if !assert.ObjectsAreEqual([]string{"Linux", "MacOS X", "UNIX", "Windows"}, cve.PlatformList) {
		t.Error("cve.PlatformList does not match at id 17")
	}

	if !assert.ObjectsAreEqual([]string{"Google Chrome < 79.0.3945.79", "Red Hat Enterprise Linux", "Debian Linux", "Open Source CentOS"}, cve.SoftwareList) {
		t.Error("cve.SoftwareList does not match at id 17")
	}
}

func TestAddCommentAssigned(t *testing.T) {
	cveComment := alertmanager.CveCaseComment{CaseId: "1"}
	cveComment.NewStatus = "ASSIGNED"
	cveComment.Comment = "Working on issue"
	cveComment.Username = "Unkn0wn User"
	cveComment.FilterId = "1"
	err := alertmanager.AddComment(db, cveComment)
	assert.Equal(t, nil, err, "AddComment returns an error")

	cveSearchCriteria := alertmanager.CveCaseSearchCriteria{Status: "ASSIGNED", FilterId: "1"}
	searchResults, err := alertmanager.SearchCases(db, cveSearchCriteria)
	if err != nil {
		log.Info().
			AnErr("Error", err).
			Msg("Could not search db")
	}
	assert.Equal(t, 1, len(searchResults), "searchResults does not match")
}

func TestReadWrongCaseId(t *testing.T) {
	cve := alertmanager.CveCase{CaseId: "-2"}
	err := cve.ReadFromDB(db, "")
	assert.Error(t, err, "Error expected")
}

func TestSearchStatus(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.Status = "NEW"
	cveSearch.FilterId = "1"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	assert.Equal(t, 240, len(cveCaseArray), "CveCaseArray does not match expected")
}

func TestSearchSource(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.Source = "CERT"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	cveCases, err := extractCaseIdsFromCases(cveCaseArray)
	if err != nil {
		log.Error().
			AnErr("Error", err)
	}
	expected := make([]int64, 300)
	for i := 0; i < 300; i++ {
		expected[i] = int64(300 - i)
	}
	if !assert.ObjectsAreEqual(expected, cveCases) {
		t.Error("CveCases does not match as expected!")

		assert.Equal(t, 300, len(cveCaseArray), "CveCaseArray does not match expected")
	}
}

func TestSearchSubject(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.Subject = "[CERT-Bund] CB-K20/0060 Update 1 - OpenJPEG: Schwachstelle ermöglicht Denial of Service"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	if len(cveCaseArray) >= 1 {
		cveCases, err := extractCaseIdsFromCases(cveCaseArray)
		if err != nil {
			log.Error().
				AnErr("Error", err)
		}
		expected := []int64{6}
		if !assert.ObjectsAreEqual(expected, cveCases) {
			t.Error("CveCases does not match as expected!")
		}
		assert.Equal(t, 1, len(cveCaseArray), "CveCaseArray does not match expected")
	}
}

func TestSearchRefNum(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.RefNum = "CB-K20/0060 Update 1"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	if len(cveCaseArray) >= 1 {
		cveCases, err := extractCaseIdsFromCases(cveCaseArray)
		if err != nil {
			log.Error().
				AnErr("Error", err)
		}
		expected := []int64{6}
		if !assert.ObjectsAreEqual(expected, cveCases) {
			t.Error("CveCases does not match as expected!")
		}
		assert.Equal(t, 1, len(cveCaseArray), "CveCaseArray does not match expected")
	}
}

func TestSearchID(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.CaseId = "122"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	if len(cveCaseArray) >= 1 {
		cveCases, err := extractCaseIdsFromCases(cveCaseArray)
		if err != nil {
			log.Error().
				AnErr("Error", err)
		}
		expected := []int64{122}
		if !assert.ObjectsAreEqual(expected, cveCases) {
			t.Error("CveCases does not match as expected!")
			assert.Equal(t, 1, len(cveCaseArray), "CveCaseArray does not match expected")
		}
	}
}

func TestSearchCombined(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.CaseId = "1"
	cveSearch.Status = "ASSIGNED"
	cveSearch.FilterId = "1"
	cveSearch.Source = "CERT"
	cveSearch.Subject = "[CERT-Bund] CB-K20/0056 Update 3 - Google Chrome: Mehrere Schwachstellen"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	if len(cveCaseArray) >= 1 {
		assert.Equal(t, 1, len(cveCaseArray), "CveCaseArray does not match expected")
	}
}

func TestCategories1(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.Category = "Anwendung/Server/Datenbanken/MySQL"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 2)
	cveCases, err := extractCaseIdsFromCases(cveCaseArray)
	if err != nil {
		log.Error().
			AnErr("Error", err)
	}
	expected := []int64{114, 11}
	if !assert.ObjectsAreEqual(expected, cveCases) {
		t.Error("CveCases does not match as expected!")
	}
}

func TestCategories2(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.Category = "Betriebssystem/Linux_Unix"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 165)
}

func TestFilter1(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.FilterId = "4"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 75)
}

func TestFilter2(t *testing.T) {
	cveSearch := alertmanager.CveCaseSearchCriteria{}
	cveSearch.FilterId = "1"
	cveSearch.Status = "ASSIGNED"
	cveCaseArray, err := alertmanager.SearchCases(db, cveSearch)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 1)
}

func TestFilterCombinedLinux(t *testing.T) {
	cveFilter := alertmanager.CveCaseSearchCriteria{}
	cveFilter.CaseId = "3"
	cveFilter.Category = "Betriebssystem/Linux_Unix/SuSE"
	cveFilter.Source = "CERT"
	cveFilter.Status = "NEW"
	cveFilter.FilterId = "1"
	cveFilter.Subject = "[CERT-Bund] CB-K20/0039 Update 8 - Oracle Java SE: Mehrere Schwachstellen"
	cveFilter.RefNum = "CB-K20/0039 Update 8"
	cveCaseArray, err := alertmanager.SearchCases(db, cveFilter)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 1)
}

func TestFilterCombinedWindows(t *testing.T) {
	cveFilter := alertmanager.CveCaseSearchCriteria{}
	cveFilter.CaseId = "121"
	cveFilter.Category = "Anwendung/Clients/Browser/Chrome"
	cveFilter.Source = "CERT"
	cveFilter.Status = "NEW"
	cveFilter.FilterId = "2"
	cveFilter.Subject = "[CERT-Bund] CB-K20/0097 Update 2 - Google Chrome / Chrome Based Edge: Mehrere Schwachstellen"
	cveFilter.RefNum = "CB-K20/0097 Update 2"
	cveCaseArray, err := alertmanager.SearchCases(db, cveFilter)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 1)
}

func TestFilterCombinedNetwork(t *testing.T) {
	cveFilter := alertmanager.CveCaseSearchCriteria{}
	cveFilter.CaseId = "252"
	cveFilter.Category = "Anwendung/Server/Web_Content_Management/Drupal"
	cveFilter.Source = "CERT"
	cveFilter.Status = "NEW"
	cveFilter.FilterId = "3"
	cveFilter.Subject = "[CERT-Bund] CB-K20/0149 - Drupal: Schwachstelle ermöglicht Umgehen von Sicherheitsvorkehrungen"
	cveFilter.RefNum = "CB-K20/0149"
	cveCaseArray, err := alertmanager.SearchCases(db, cveFilter)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 1)
}

func TestFilterCombinedOther(t *testing.T) {
	cveFilter := alertmanager.CveCaseSearchCriteria{}
	cveFilter.CaseId = "189"
	cveFilter.Category = "Anwendung/Clients/Browser/Safari"
	cveFilter.Source = "CERT"
	cveFilter.Status = "NEW"
	cveFilter.FilterId = "4"
	cveFilter.Subject = "[CERT-Bund] CB-K20/0084 Update 3 - Apple Safari: Mehrere Schwachstellen"
	cveFilter.RefNum = "CB-K20/0084 Update 3"
	cveCaseArray, err := alertmanager.SearchCases(db, cveFilter)
	assert.NoError(t, err)
	assert.True(t, len(cveCaseArray) == 1)
}

func TestAddFilterAndFilterCategory(t *testing.T) {
	err := alertmanager.AddFilter(db, `IT-Betrieb`)
	assert.NoError(t, err)
	err = alertmanager.AddFilterCategory(db, "5", "Anwendung/Server/Web_Proxy_Fileserver/Apache_Tomcat")
	assert.NoError(t, err)
	_, err = db.Exec(db.Rebind("DELETE FROM filter_categories WHERE filter_categories.category = 'Anwendung/Server/Web_Proxy_Fileserver/Apache_Tomcat' AND filter_categories.filter_id =  5"))
	assert.NoError(t, err)
	err = alertmanager.DeleteFilter(db, "5")
	assert.NoError(t, err)
}

func TestDeleteFilter(t *testing.T) {
	_, err := db.Exec(db.Rebind("INSERT INTO filters (filters.filter) VALUES ('IT-Betrieb')"))
	assert.NoError(t, err)
	err = alertmanager.DeleteFilter(db, "6")
	assert.NoError(t, err)
}

func TestDeleteFilterCategory(t *testing.T) {
	_, err := db.Exec(db.Rebind("INSERT INTO filters (filters.filter) VALUES ('IT-Betrieb')"))
	assert.NoError(t, err)
	_, err = db.Exec(db.Rebind("INSERT INTO filter_categories (filter_id, category) VALUES (7, 'Anwendung/Server/Web_Proxy_Fileserver/Apache_Tomcat')"))
	assert.NoError(t, err)
	err = alertmanager.DeleteFilterCategory(db, "83")
	assert.NoError(t, err)
	err = alertmanager.DeleteFilter(db, "7")
	assert.NoError(t, err)
}
