package cmd

import (
	alertmanager "cve-alert-manager"
	"cve-alert-manager/cve-alert-fetcher/fetcher"
	"fmt"
	_ "github.com/go-sql-driver/mysql" //needed for initializing connection
	"github.com/jmoiron/sqlx"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"os"
	"strings"
)

var cfgFile string

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "cve-alert-fetcher",
	Short: "Fetches cve-alerts from various sources",
	Long: `This tool is part of the suit, this component is responsible for pulling cve incidents from different data sources, normalizing and storing them in a database

Normally the program is called periodically to retrieve new incidents, this is typically done via crond or systemd

Currently "cert-bund" is supported as the only possible data source

In order to use this data source, you must first register with the "Warning and Information Service of CERT-Bund"and subscribe to the desired messages 
so that they are delivered to a POP3 mailbox. This tool retrieves the emails via POP3, normalizes them and puts them into the database. 

All parameters (such as access data) can be specified both on the command line and in a config file `,
	// Uncomment the following line if your bare application
	// has an action associated with it:
	Run: func(cmd *cobra.Command, args []string) {
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
		loglevel := cmd.Flag("log-level").Value.String()
		source := cmd.Flag("source").Value.String()
		if !validateSource(source) {
			log.Error().
				Msg("Invalid source")
			os.Exit(1)
		}
		if !validateLogLevel(loglevel) {
			log.Error().
				Msg("Invalid log-level")
			os.Exit(1)
		}
		err := parseAndSetLogLevel(loglevel)
		if err != nil {
			log.Error().
				AnErr("Error: ", err).
				Msg("The Log Level could not be parsed")
			os.Exit(1)
		}

		var db *sqlx.DB = nil
		if !viper.GetBool("dry-run") {
			var err error
			if viper.GetString("cveDatabase.driverName") == "" {
				log.Error().
					Msg("config variable cveDatabase.driverName is not set")
				return
			}
			if viper.GetString("cveDatabase.dataSourceName") == "" {
				log.Error().
					Msg("config variable cveDatabase.dataSourceName is not set")
				return
			}
			db, err = sqlx.Open(viper.GetString("cveDatabase.driverName"), viper.GetString("cveDatabase.dataSourceName"))
			if err != nil {
				log.Error().
					AnErr("Error", err).
					Msg("Could not connect to database")
				return
			}
			if viper.GetBool("init-db") {
				log.Info().
					Msg("init-db - initialize database structure")

				err = alertmanager.InitDB(db)
				if err != nil {
					log.Error().
						AnErr("Error", err).
						Msg("Could not initialize database structure")
					return
				}
			}
		} else {
			log.Info().
				Msg("dry-run - no database changes")
		}

		switch source {
		case "cert-bund":
			fetcher.FetchCertBund(db)
			break
		case "nist":
			fetcher.FetchNist()
			break
		default:
			break
		}
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)
	// Here you will define your flags and configuration settings.
	// Cobra supports persistent flags, which, if defined here,
	// will be global for your application.

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/config.yaml)")
	rootCmd.Flags().String("log-level", "info", "Use this flag to set the log level")
	rootCmd.Flags().String("source", "cert-bund", "Use this flag to set the source")
	rootCmd.Flags().Bool("dry-run", false, "Use this flag to perform a dry-run (no database actions)")
	rootCmd.Flags().Bool("init-db", false, "Use this flag to initially create the database structure (tables and indexes)")
	rootCmd.Flags().Bool("read-db", false, "Use this flag to read an entry from database for testing/debugging purposes")
	rootCmd.Flags().Bool("no-dele", false, "Use this flag to keep the parsed mails from the POP3 client")
	viper.BindPFlag("dry-run", rootCmd.Flags().Lookup("dry-run"))
	viper.BindPFlag("init-db", rootCmd.Flags().Lookup("init-db"))
	viper.BindPFlag("read-db", rootCmd.Flags().Lookup("read-db"))
	viper.BindPFlag("no-dele", rootCmd.Flags().Lookup("no-dele"))
	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	// rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			log.Error().
				AnErr("Error:", err)
		}
		// Search config
		viper.AddConfigPath(home + "/.cve-alert-manager")
		viper.AddConfigPath("../config")
		viper.AddConfigPath("/var/opt/cve-alert-manager")
		viper.SetConfigName("config")
	}

	replacer := strings.NewReplacer(".", "_")
	viper.SetEnvKeyReplacer(replacer)

	viper.SetEnvPrefix("CVE_ALERT_MANAGER")
	viper.AutomaticEnv() // read in environment variables that match

	err := viper.ReadInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}

	viper.SetConfigName("filter_config")
	err = viper.MergeInConfig()
	if err != nil {
		log.Error().
			AnErr("Error:", err).
			Msg("Failed reading in config")
	}
}

func parseAndSetLogLevel(loglevel string) error {
	parsedLoglevel, err := zerolog.ParseLevel(loglevel)
	if err != nil {
		log.Error().
			AnErr("Error: ", err)
		return err
	}
	zerolog.SetGlobalLevel(parsedLoglevel)
	return nil
}

func validateLogLevel(level string) bool {
	allowedLevels := []string{"panic", "fatal", "error", "warn", "info", "debug", "trace"}

	for _, allowedLevel := range allowedLevels {
		if level == allowedLevel {
			return true
		}
	}

	return false
}

func validateSource(source string) bool {
	allowedSources := []string{"cert-bund", "nist"}

	for _, allowedSource := range allowedSources {
		if source == allowedSource {
			return true
		}
	}

	return false
}
